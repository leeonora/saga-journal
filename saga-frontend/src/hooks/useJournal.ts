
"use client";

import { useState, useEffect, useCallback } from "react";
import type { JournalEntry, PromptType } from "@/lib/types";

// The base URL for your FastAPI backend
const API_URL = "http://127.0.0.1:8000";

export function useJournal() {
  const [entries, setEntries] = useState<JournalEntry[]>([]);
  const [isLoaded, setIsLoaded] = useState(false);

  // Fetch all entries from the backend when the component mounts
  useEffect(() => {
    const fetchEntries = async () => {
      try {
        const response = await fetch(`${API_URL}/journal/`);
        if (!response.ok) {
          throw new Error('Failed to fetch entries');
        }
        const data = await response.json();
        // Assuming your backend returns { "entries": [...] }
        const sortedEntries = (data.entries || []).sort((a: JournalEntry, b: JournalEntry) => new Date(b.date).getTime() - new Date(a.date).getTime());
        setEntries(sortedEntries);
      } catch (error) {
        console.error("Error fetching entries from backend:", error);
        setEntries([]); // Set to empty array on error
      } finally {
        setIsLoaded(true);
      }
    };

    fetchEntries();
  }, []);

  const addEntry = useCallback(async (content: string, date: Date, promptType: PromptType, prompt: string | undefined, title: string | undefined): Promise<JournalEntry | undefined> => {
    if (!content.trim()) return;

    try {
      const response = await fetch(`${API_URL}/journal/`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          title: title || 'Untitled Entry',
          content: content,
          date: date.toISOString(),
          // Summary is now generated by the backend, so we don't send it.
          // The backend will return the full entry with the summary.
        }),
      });

      if (!response.ok) {
        throw new Error('Failed to add entry');
      }

      const { entry: newEntry } = await response.json();
      
      // Add the new entry to the local state
      setEntries(prevEntries => [newEntry, ...prevEntries].sort((a,b) => new Date(b.date).getTime() - new Date(a.date).getTime()));
      
      return newEntry;

    } catch (error) {
      console.error("Error adding entry:", error);
      return undefined;
    }
  }, []);
  
  // const updateEntry = useCallback(async (id: string, content: string, date: Date, promptType: PromptType, prompt: string | undefined, title: string | undefined): Promise<JournalEntry | undefined> => {
  //   // Note: The provided main.py doesn't have an update endpoint.
  //   // You will need to implement a `PUT /journal/{entry_id}` or similar endpoint in your FastAPI backend.
  //   // For now, this function will log a message.
  //   console.log("Update functionality needs a corresponding backend endpoint.");
    
  //   // Once you have an endpoint, the logic would look something like this:
  //   /*
  //   try {
  //     const response = await fetch(`${API_URL}/journal/${id}`, {
  //       method: 'PUT',
  //       headers: { 'Content-Type': 'application/json' },
  //       body: JSON.stringify({ title, content }),
  //     });

  //     if (!response.ok) {
  //       throw new Error('Failed to update entry');
  //     }

  //     const updatedEntry = await response.json();

  //     setEntries(prevEntries => 
  //       prevEntries.map(entry => (entry.id === id ? updatedEntry : entry))
  //     );

  //     return updatedEntry;
  //   } catch (error) {
  //     console.error("Error updating entry:", error);
  //     return undefined;
  //   }
  //   */
    
  //   // Returning the existing entry optimistically for the UI
  //   const entryToUpdate = entries.find(e => e.id === id);
  //   if(entryToUpdate) {
  //       const updated = { ...entryToUpdate, content, title: title || entryToUpdate.title, date: date.toISOString() };
  //       setEntries(prev => prev.map(e => e.id === id ? updated : e));
  //       return updated;
  //   }

  //   return undefined;
  // }, [entries]);


  const updateEntry = useCallback(
    async (
      id: string,
      content: string,
      date: Date,
      promptType: PromptType,
      prompt: string | undefined,
      title: string | undefined
    ): Promise<JournalEntry | undefined> => {
      try {
        const response = await fetch(`${API_URL}/journal/${id}`, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            title: title || 'Untitled Entry',
            content,
            date: date.toISOString(),
            // Do not send summary; backend can regenerate if needed
          }),
        });
  
        if (!response.ok) {
          throw new Error('Failed to update entry');
        }
  
        // FastAPI should return { entry: { ... } }
        const { entry: updatedEntry } = await response.json();
  
        // Update local state with the returned updated entry
        setEntries(prevEntries =>
          prevEntries.map(entry => (entry.id === id ? updatedEntry : entry))
        );
  
        return updatedEntry;
      } catch (error) {
        console.error("Error updating entry:", error);
        return undefined;
      }
    },
    []
  );

  const deleteEntry = useCallback(async (id: string) => {
    try {
      const response = await fetch(`${API_URL}/journal/${id}`, {
        method: 'DELETE',
      });

      if (!response.ok) {
        throw new Error('Failed to delete entry');
      }

      setEntries(prevEntries => prevEntries.filter(entry => entry.id !== id));
    } catch (error) {
      console.error("Error deleting entry:", error);
    }
  }, []);


  return { entries, addEntry, updateEntry, deleteEntry, isLoaded };
}
